# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hh7i1DtYmB7hrPlIiIvz7v3lwHByIZhy
"""

#Exercise 2.2 
import numpy as np
import matplotlib.pyplot as plt
from skimage.transform import warp
import math

square = np.ones((11, 11), dtype=np.double)
square = np.pad(square, 40)
plt.imshow(square, cmap="gray")

def transform(im, t, s, theta):
  c = [im.shape[0]//2, im.shape[1]//2]
  
  Tc = np.array([[1.,0,-c[0]],[0,1.,-c[1]],[0,0,1.]])
  T = np.array([[1.,0,-t[0]],[0,1.,-t[1]],[0,0,1.]])
  TcI = np.array([[1.,0,c[0]],[0,1.,c[1]],[0,0,1.]])
  R = np.array([[math.cos(theta), -math.sin(theta), 0], [math.sin(theta), math.cos(theta), 0], [0, 0, 1.]])
  S = np.array([[1/s,0,0],[0,1/s,0],[0,0,1.]])
  
  w = warp(im, TcI, order=0)
  w = warp(w, S, order=0)
  w = warp(w, R, order=0)
  w = warp(w, Tc, order=0)
  w = warp(w, T, order=0)

  return w

plt.imshow(transform(square, [10.4, 15.7], 2.0, math.pi/10), cmap="gray")

# Exercise 3.1 
from scipy.ndimage import convolve, gaussian_filter
from skimage.io import imread

def harris(A, t, a, k):
  result = np.zeros((A.shape[0], A.shape[1], t.shape[0]))
  for i in range(0, t.shape[0]):
    Lx = gaussian_filter(A, t[i], order=(1,0))
    Ly = gaussian_filter(A, t[i], order=(0,1))
    Lxx = gaussian_filter(Lx**2, sigma=k*t[i])
    Lxy = gaussian_filter(Ly*Lx, sigma=k*t[i])
    Lyy = gaussian_filter(Ly**2, sigma=k*t[i])
    tr = Lxx + Lyy
    d = Lxx * Lyy - Lxy ** 2
    result[:,:,i] = t[i]**4 * (d - a * tr ** 2)
  return result

def find_spatial_max(L):
    """Detect spatial maxima in scale-space L (assuming it is a 3D array).
    Returns an array of row, cols, scale level into L."""
    
    # Find maxima in space
    for l in range(0, L.shape[2]):
        # Find local maxima in space
        p_max=peak_local_max(L[:,:,l])
        # Add scale level index
        p_max = np.hstack([p_max, l*np.ones((p_max.shape[0],1), dtype=int)] )
                    
        # Add to results
        if l==0: # First time
            p_maxi = p_max
        else: # later
            p_maxi = np.vstack([p_maxi, p_max])
            
    return p_maxi

def find_scale_max(L, p_maxi):
    """Find maxima in L across scale at points in p_maxi.
    Compares only pixel above and below and handles boundaries of scale-space.
    Returns a pruned list of points"""

    # Find maxima across scale
    keep = np.zeros((p_maxi.shape[0],), dtype=bool)
    for i in range(0,p_maxi.shape[0]):
        p = p_maxi[i,:]
        Lcenter = L[p[0], p[1], p[2]]
        if p[2] > 0:
            Lup = L[p[0], p[1], p[2]-1]
        else:
            Lup = -np.inf
            
        if p[2] < L.shape[2]-1:
            Ldown = L[p[0], p[1], p[2]+1]
        else:
            Ldown = -np.inf
        
        if Lcenter > Lup and Lcenter > Ldown: 
            keep[i] = True
    
    return p_maxi[keep,:]


def find_scalespace_max(L):
    """Detect maxima in the scale-space L (assuming it is a 3D array).
    Returns a list of indices into L corresponding to maxima."""
    
    # Find spatial maxima
    p_maxi = find_spatial_max(L)
    
    # Find maxima across scale
    p_maxi = find_scale_max(L, p_maxi)
        
    return p_maxi


def keep_strongest_points(L, points, num_p):
    
    sorted_idx = L[points[:,0], points[:,1], points[:,2]].argsort()
    if sorted_idx.shape[0] >= num_p:
        strongest_idx = sorted_idx[-(num_p+1):-1]
    else:
        strongest_idx = sorted_idx
        
    return points[np.flip(strongest_idx)]

def plot_features(ax, points, tau, color='r'):
    """Plot points and circles"""
    plt.plot(points[:,1], points[:,0], color+'.')
    # Draw circles with radii given by detection scale
    for i in range(0, points.shape[0]):
        c = plt.Circle((points[i,1], points[i,0]), points[i,2], color=color, linewidth=1.5, fill=False)    
        ax.add_patch(c)
    
    ax.plot()

from skimage.color import gray2rgb
from skimage.feature import peak_local_max

original = 1/255 * imread("/content/modelhouses.png", 0)
t=np.logspace(0, 5, 30, base=2)
harrisCorners = harris(original, t, 0.05, 1.0)
maxP = find_scalespace_max(harrisCorners)
maxP = keep_strongest_points(harrisCorners, maxP, 350)

fig, ax = plt.subplots(figsize=(6,4))
ax.imshow(original, cmap="gray")
ax.set_title("350 points with largest $R(x, y, \sigma)$")
plot_features(ax, maxP, t)

#Exercise 4.3 
from scipy import ndimage
from skimage.color import rgb2hsv
from skimage.morphology import area_opening
from skimage.exposure import histogram
from skimage.filters import threshold_otsu

def find_threshold(im):    
    hist, cs = histogram(im.ravel()) 

    w1 = np.cumsum(hist) 
    w2 = np.cumsum(hist[::-1])[::-1] 

    m1 = np.cumsum(hist * cs) / w1 
    m2 = (np.cumsum((hist * cs)[::-1]) / w2[::-1])[::-1] 

    thres = cs[:-1][np.argmax(w1[:-1] * w2[1:] * (m1[:-1] - m2[1:]) ** 2 ) ] 
    return thres

coins = plt.imread('/content/coins.png')
euros = plt.imread('/content/overlapping_euros1.png')
freq, bins = histogram(euros)
plt.plot(bins, freq*1.0/freq.sum())
plt.title('Histogram for euros')
plt.xlabel('Intensity')
plt.ylabel('Pixels');
coins2 = find_threshold(coins)
euros2 = find_threshold(euros)
coins_threshold  = coins < coins2
euros_threshold = euros < euros2

plt.title('Coins segmentation')
plt.gray()
plt.imshow(coins_threshold)

plt.title('Euros segmentation')
plt.imshow(euros_threshold)

from imageio import imread
from skimage.color import rgb2gray
import numpy as np
from scipy import fftpack as fp
from scipy import signal
import matplotlib.pyplot as plt
from skimage.util import random_noise


# Exercise 5.1
A = imread('/content/trui.png')
gaussianKernel = np.outer(signal.gaussian(A.shape[0], 3),
signal.gaussian(A.shape[1], 3))
H = fp.fft2(fp.ifftshift(gaussianKernel)) 
conv = fp.fft2(A)*H
blurredImage = fp.ifft2(conv).real
blurredImage = 255 * blurredImage / np.max(blurredImage)
blurredImage = random_noise(blurredImage, mode='speckle', seed=None, clip=False)
plt.imshow(blurredImage, cmap="gray")

import pylab
#Exercise 5.2 
epsilon = 10**-6
H = 1 / (epsilon + H) 
conv = fp.fft2(blurredImage)*H
restoredImage = fp.ifft2(conv).real
restoredImage = 255 * restoredImage / np.max(restoredImage)
pylab.figure(figsize=(10,10))
pylab.gray()
pylab.subplot(221), pylab.imshow(A), pylab.title('Original image'), pylab.axis('off')
pylab.subplot(222), pylab.imshow(blurredImage), pylab.title('Blurred image'), pylab.axis('off')
pylab.subplot(223), pylab.imshow(restoredImage), pylab.title('Restored image with inverse filter'), pylab.axis('off')
pylab.subplot(224), pylab.imshow(restoredImage - A), pylab.title('Diff restored & original image'), pylab.axis('off')
pylab.show()