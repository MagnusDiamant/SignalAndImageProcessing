# -*- coding: utf-8 -*-
"""SIP_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VCKCZ_u5Z3UXq8SE2lGKkzr1hVJ0lW0r
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import cv2

# Assignment 1
from skimage.morphology import disk
disk_rad2 = disk(2)
disk_rad2

img = plt.imread("/content/cells_binary.png")
print(img)
plt.imshow(img)
plt.title('Orginial image')
plt.gray()
opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, disk_rad2)

plt.title('Morphological opening')
plt.plot((300), (200), 'o', color='r')
plt.plot((400), (150), 'o', color='r')
plt.imshow(opening)

closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, disk_rad2)
plt.title('Morphological closing')
plt.plot((250), (400), 'o', color='r')
plt.plot((460), (470), 'o', color='r')
plt.plot((120), (80), 'o', color='r')
plt.imshow(closing)

from scipy import ndimage
import numpy as np
from skimage import morphology
from skimage.io import imread

A = imread("/content/blobs_inv.png")
vertical = np.array([[1.],[1.],[1.],[1.],[1.]])
disk = morphology.disk(2)
corner = np.array([[0,0,0], [1.,1.,0], [1.,1.,0]])
fig, ax = plt.subplots(2, 2, figsize=(14,12))
ax[0, 0].set_title("Original image")
ax[0, 0].imshow(A, cmap="gray")
hitVert = ndimage.binary_hit_or_miss(A, structure1=vertical)
ax[0, 1].set_title("Vertical line hit or miss")
ax[0, 1].imshow(hitVert, cmap="gray")
hitDisk = ndimage.binary_hit_or_miss(A, structure1=disk)
ax[1, 0].set_title("Disk, radius = 2 hit or miss")
ax[1, 0].imshow(hitDisk, cmap="gray")
hitCorner = ndimage.binary_hit_or_miss(A, structure1=corner)
ax[1, 1].set_title("Corner hit or miss")
ax[1, 1].imshow(hitCorner, cmap="gray")
fig, ax = plt.subplots(2, 2, figsize=(14,12))
ax[0, 0].set_title("Original image")
ax[0, 0].imshow(A, cmap="gray")
topVert = morphology.white_tophat(A, selem=vertical)
ax[0, 1].set_title("Vertical line White top hat")
ax[0, 1].imshow(topVert, cmap="gray")
topDisk = morphology.white_tophat(A, selem=disk)
ax[1, 0].set_title("Disk, radius = 2 White top hat")
ax[1, 0].imshow(topDisk, cmap="gray")
topCorner = morphology.white_tophat(A, selem=corner)
ax[1, 1].set_title("Corner White top hat")
ax[1, 1].imshow(topCorner, cmap="gray")
fig, ax = plt.subplots(2, 2, figsize=(14,12))
ax[0, 0].set_title("Original image")
ax[0, 0].imshow(A, cmap="gray")
bottomVert = morphology.black_tophat(A, selem=vertical)
ax[0, 1].set_title("Vertical line, black top hat")
ax[0, 1].imshow(bottomVert, cmap="gray")
bottomDisk = morphology.black_tophat(A, selem=disk)
ax[1, 0].set_title("Disk, radius = 2, black top hat")
ax[1, 0].imshow(bottomDisk, cmap="gray")
bottomCorner = morphology.black_tophat(A, selem=corner)
ax[1, 1].set_title("Corner, black top hat")
ax[1, 1].imshow(bottomCorner, cmap="gray")

from skimage import filters
image1 = imread("/content/digits_binary_inv.png")/65278
imageFiltered = image1<filters.threshold_mean(image1)
m = imageFiltered[0:45, 60:95]
mLittle = morphology.erosion(m, morphology.disk(2))
mMore = morphology.dilation(m, morphology.disk(5))
mMost = morphology.dilation(m, morphology.disk(6))
mWin = np.bitwise_xor(mMore, mMost)

adaptMask = imageFiltered[14:25, 60:95]
adaptMaskSlightly = morphology.erosion(adaptMask, morphology.disk(2))
adaptMaskBigger = morphology.dilation(m, morphology.disk(5))
adaptMaskBiggest = morphology.dilation(m, morphology.disk(6))
adaptMaskWindow = np.bitwise_xor(adaptMaskBigger, adaptMaskBiggest)
first = morphology.erosion(imageFiltered, mLittle)
second = morphology.erosion(np.invert(imageFiltered), mWin).astype(bool)

plt.figure(figsize=(14,12))
plt.imshow(mLittle, cmap="gray")
plt.show()
plt.figure(figsize=(14,12))
plt.imshow(mWin, cmap="gray")
plt.show()
plt.figure(figsize=(14,12))
plt.imshow(imageFiltered, cmap="gray")
plt.show()
plt.figure(figsize=(14,12))
plt.imshow(first, cmap="gray")
plt.show()
plt.figure(figsize=(14,12))
plt.imshow(second, cmap="gray")
plt.show()
plt.figure(figsize=(14,12))
plt.imshow(np.bitwise_and(first, second), cmap="gray")
plt.show()

from skimage import color, segmentation, measure
import matplotlib.patches as mpatches
image1 = color.gray2rgb(image1)
label = measure.label(np.bitwise_and(first, second))
overlay = color.label2rgb(label, image=image1, bg_label=0, bg_color=None)
fig, ax = plt.subplots(figsize=(14,12))
ax.imshow(overlay)
for r in measure.regionprops(label):
  minR, minC, _, _ = r.bbox
  rectangle = mpatches.Rectangle((minC-10, minR-18), 20, 35, fill=False, edgecolor="blue", linewidth=3)
  ax.add_patch(rectangle)

image1 = imread("/content/money_bin.jpg")
c = image1 < filters.threshold_mean(image1)
plt.imshow(image1)
plt.show()

coin1 = c[287:370, 306:380]
coin2 = c[60:160, 170:265]
coin5 = c[75:180, 60:175]
coin20 = c[175:270, 0:105]
coin50 = c[270:350, 35:115]

def countCoins(m, c):
  mLittle = morphology.erosion(m, morphology.disk(4))
  mMore = morphology.dilation(m, morphology.disk(3))
  mMost = morphology.dilation(m, morphology.disk(4))
  mWin = np.bitwise_xor(mMore, mMost)
  first = morphology.erosion(c, mLittle)
  second = morphology.erosion(np.invert(c), mWin).astype(bool)
  r = measure.regionprops(measure.label(np.bitwise_and(first, second)))
  return len(r)

coins = [{"value": 0.5, "m": coin50},
         {"value": 1, "m": coin1},
         {"value": 2, "m": coin2},
         {"value": 5, "m": coin5},
         {"value": 20, "m": coin20}]

sum = 0
for coin in coins:
  sum += countCoins(coin["m"], c) * coin["value"]

print(sum)

import pandas as pd
import numpy as np

xTrainOriginal = np.loadtxt('/content/SIPdiatomsTrain.txt', delimiter=',')
yTrainOriginal = np.loadtxt('/content/SIPdiatomsTrain_classes.txt', delimiter=',')


xTestOriginal = np.loadtxt('/content/SIPdiatomsTest.txt', delimiter=',')
yTestOriginal = np.loadtxt('/content/SIPdiatomsTest_classes.txt', delimiter=',')


from sklearn.neighbors import KNeighborsClassifier

knn = KNeighborsClassifier() 
knn.fit(xTrainOriginal, yTrainOriginal)
preds = knn.predict(xTestOriginal)
acc = sum(preds == yTestOriginal) / len(yTestOriginal)

print(xTrainOriginal.shape)
print(acc)

## Exercise 2.1
import matplotlib.pyplot as plt
newXTrain = [] 
for i in xTrainOriginal: 
  B = np.reshape(i, (-1, 2))
  newXTrain.append(B)

xTrain = np.array(newXTrain)

newXTest = [] 
for i in xTestOriginal: 
  B = np.reshape(i, (-1, 2))
  newXTest.append(B)

xTest = np.array(newXTest)

plt.title("First diatom of the training set")
plt.xlabel("x1")
plt.ylabel("y1")
plt.plot(xTrainOriginal[0])

def procrustes(X, Y):
    rows,cols = X.shape
    rowsY,colsY = Y.shape
    meanX = X.mean(0)
    meanY = Y.mean(0)
    X0 = X - meanX
    Y0 = Y - meanY
    squaredSumX = (X0**2.).sum()
    squaredSumY = (Y0**2.).sum()
    frobNormX = np.sqrt(squaredSumX)
    frobNormY = np.sqrt(squaredSumY)
    X0 /= frobNormX
    Y0 /= frobNormY
    if colsY < cols:
        Y0 = np.concatenate((Y0, np.zeros(rows, cols-colsY)),0)
    XY = np.dot(X0.T, Y0)
    U,s,Vtrans = np.linalg.svd(XY,full_matrices=False)
    V = Vtrans.T
    VU = np.dot(V, U.T)
    optScale = s.sum() * frobNormX / frobNormY
    standDist = 1 - s.sum()**2
    transPoints = frobNormX*s.sum()*np.dot(Y0, VU) + meanX
    if colsY < cols:
        VU = VU[:colsY,:]
    tMatrix = meanX - optScale*np.dot(meanY, VU)
    
    tValues = {'rotation':VU, 'scale':optScale, 'translation':tMatrix}
   
    return standDist, transPoints, tValues


proTrain = [] 
proTest = [] 
targetDiatom = xTrain[0]

for i in range(len(xTrain)): 
    standDist, z, t = procrustes(targetDiatom, xTrain[i])
    proTrain.append(z.flatten())

for i in range(len(xTest)): 
    standDist, z, t = procrustes(targetDiatom, xTest[i])
    proTest.append(z.flatten())

plt.title("Second diatom of the training set")
plt.xlabel("x2")
plt.ylabel("y2")
plt.plot(xTrainOriginal[1])

plt.title("Second diatom of the training set after Procrustes transformation")
plt.xlabel("x2")
plt.ylabel("y2")
plt.plot(proTrain[1])

plt.title("Third diatom of the training set")
plt.xlabel("x3")
plt.ylabel("y3")
plt.plot(xTrainOriginal[2])

plt.title("Third diatom of the training set after Procrustes transformation")
plt.xlabel("x3")
plt.ylabel("y3")
plt.plot(proTrain[2])

plt.title("Fourth diatom of the training set")
plt.xlabel("x4")
plt.ylabel("y4")
plt.plot(xTrainOriginal[3])

plt.title("Fourth diatom of the training set after Procrustes transformation")
plt.xlabel("x4")
plt.ylabel("y4")
plt.plot(proTrain[3])

proTrain = np.array(proTrain)
print(proTrain.shape)
proTest = np.array(proTest)

knn = KNeighborsClassifier() 
knn.fit(proTrain, yTrainOriginal)
preds = knn.predict(proTest)
acc = sum(preds == yTestOriginal) / len(yTestOriginal)
print(acc)

image = np.zeros((3,3))
image[1,1] = 255
imgplot = plt.imshow(image)
plt.axis(False)
plt.gray()
plt.show()

def filter_image(image, x, y):
    kernel = np.zeros((3,3))
    kernel[1-y,1+x] = 1
    processed_image = cv2.filter2D(image,-1, kernel, borderType=0)
    return processed_image
filtered_image = filter_image(image, 1, 1)
imgplot = plt.imshow(filtered_image)
plt.axis(False)
plt.gray()
plt.show()

from PIL import Image
img = Image.fromarray(image)
plt.title('Original')
plt.axis(False)
plt.imshow(np.asarray(img))

plt.show()
def hom_filter(image, x, y):
    s = np.asarray(image).shape[0]
    T = np.array([
    [1, 0, x],
    [0, 1, y],
    [0, 0, 1]])
    T_inv = np.linalg.inv(T)
    img_transformed = img.transform(size=(s,s),
                                    method=Image.AFFINE, data=T_inv.flatten(), 
                                    resample=Image.NEAREST)
    return img_transformed
img_transformed = hom_filter(img, 0.6, 1.2)
plt.title('Transformed with (0.6, 1.2)T')
plt.axis(False)
plt.imshow(np.asarray(img_transformed))

import matplotlib.image as mpimg
import numpy as np
import scipy
import matplotlib.pyplot as plt
import scipy.stats as stats
import matplotlib.pyplot as pl
import scipy.stats as stats
from scipy import fft
from scipy.fftpack import fft,fft2, fftshift, ifft2, ifftshift
import image_tools
from scipy import signal
image = np.zeros((3,3))
image[1,1] = 255

def fft_shift(image,axis):
    ftimage = scipy.fft.fft2(image)
    ftimage = scipy.fft.fftshift(image, axes=axis)
    img_back = np.abs(ftimage)
    return img_back
shifted_img = fft_shift(image,1)
plt.axis(False)
plt.title('Image shifted using FFT')
plt.imshow(np.asarray(shifted_img))



