# -*- coding: utf-8 -*-
"""SIP3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ldklF20pTrnU3kX4uop2EVnv9IdRixbY
"""

!pip install image_tools

import matplotlib.image as mpimg
import numpy as np
import scipy
import matplotlib.pyplot as plt
import scipy.stats as stats
import matplotlib.pyplot as pl
import scipy.stats as stats
from scipy import fft
from scipy.fftpack import fft,fft2, fftshift, ifft2, ifftshift
import image_tools
from scipy import signal

# Assignment 2a 

image = mpimg.imread("trui.png")
ftimage = scipy.fft.fft2(image)
ftimage = scipy.fft.fftshift(ftimage)
psd = np.log10(abs(ftimage)**2)
plt.imshow((psd))
plt.colorbar(orientation='horizontal')
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# Assignment 2b
image = mpimg.imread("trui.png")
#print(image)
#print(np.size(image[0:3, 0:0+3]))

def convolve_with_loops(data, kernel_size):
    nx, ny = data.shape
    convolved=np.zeros((nx, ny))
    actual_kernel_size = kernel_size
    for i in range(0, nx):
        for j in range(0, ny):
            # set kernel_size for 'outer' values
            if i < kernel_size:
                kernel_size_i = i % kernel_size
            if j < kernel_size:
                kernel_size_j = j % kernel_size
                
            # calculate new value to convolved
            sum_ = np.sum(image[i-kernel_size_i:i+kernel_size+1, j-kernel_size_j:j+kernel_size+1])
            size_ = np.size(image[i-kernel_size_i:i+kernel_size+1, j-kernel_size_j:j+kernel_size+1])
            convolved[i, j] = sum_ / size_
            
            # reset outer kernels for i and j
            kernel_size_i = kernel_size
            kernel_size_j = kernel_size

    return convolved
convolved = convolve_with_loops(image, 15)
#print(convolved)
imgplot = plt.imshow(convolved)
plt.title('With loops and kernel_size = 15')
plt.gray()
plt.show()
image = mpimg.imread("trui.png")
def convolve_without_loops(image, kernel_size):
    kernel = np.outer(signal.windows.gaussian(len(image[0]), kernel_size),
                  signal.windows.gaussian(len(image[0]), kernel_size))
    blurred = signal.fftconvolve(image, kernel, mode='same')
    return blurred
blurred = convolve_without_loops(image, 15)
imgplot = plt.imshow(blurred)
plt.title('Without loops and kernel_size = 15')
plt.gray()
plt.show()



# %timeit convolved = convolve_with_loops(image, 15)
# %timeit convolved_2 = convolve_without_loops(image, 15)

import math
image1 = mpimg.imread("/cameraman.tif")/255
image2 = np.zeros(image1.shape)

for i in range(image1.shape[0]):
  for j in range(image1.shape[1]):
    result = 0.5*math.cos(0.2*i+0.4*j)
    if (result + image1[i, j] > 1.0):
      image2[i, j] = 1.0
    else:
      image2[i, j] = result + image1[i, j]

number = image2.shape[0]
f = scipy.fft.fft2(image2)
plt.imshow(image2)
plt.show()



k2 = np.meshgrid(np.fft.fftfreq(number) * number, np.fft.fftfreq(number) * number)
kn = (np.sqrt(k2[0]**2 + k2[1]**2)).flatten()

bs = np.arange(0.5, number//2+1, 1.)
vs = 0.5 * (bs[1:] + bs[:-1])
mBs, _, _ = stats.binned_statistic(kn, (np.abs(f)**2).flatten(), bins = bs)
mBs *= np.pi * (bs[1:]**2 - bs[:-1]**2)

plt.loglog(vs, mBs)
plt.title("Power Spectrum")
plt.xlabel("k")
plt.ylabel("P(k)")
plt.show()

fk1 = np.zeros((image1.shape[0], image1.shape[0]))
for i in range(image1.shape[0]):
  for j in range(image1.shape[1]):
    fk1[i, j] = 0.5*math.cos(0.2*i+0.4*j)

fk2 = np.zeros((image1.shape[0], image1.shape[0]))
for i in range(image1.shape[0]):
  for j in range(image1.shape[1]):
    fk2[i, j] = 0.5 - 0.5*math.cos(0.2*i+0.4*j)

plt.imshow(fk2 + image2)

